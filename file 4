 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/backend/src/server.js b/backend/src/server.js
new file mode 100644
index 0000000000000000000000000000000000000000..80404149a33cf8d9b15792dfff02686a2950f8c1
--- /dev/null
+++ b/backend/src/server.js
@@ -0,0 +1,305 @@
+import 'dotenv/config';
+import crypto from 'node:crypto';
+import express from 'express';
+import cors from 'cors';
+import jwt from 'jsonwebtoken';
+import Stripe from 'stripe';
+import { v4 as uuidv4 } from 'uuid';
+import { z } from 'zod';
+
+const app = express();
+const port = Number(process.env.PORT ?? 4000);
+const stripe = process.env.STRIPE_SECRET_KEY ? new Stripe(process.env.STRIPE_SECRET_KEY) : null;
+
+const TIER_LIMITS = {
+  builder: { monthlyGenerations: 25, canExportEngines: false, watermark: true, multiplayer: false },
+  pro: { monthlyGenerations: 150, canExportEngines: true, watermark: false, multiplayer: false },
+  studio: { monthlyGenerations: Number.POSITIVE_INFINITY, canExportEngines: true, watermark: false, multiplayer: true },
+  creatorElite: { monthlyGenerations: Number.POSITIVE_INFINITY, canExportEngines: true, watermark: false, multiplayer: true }
+};
+
+const projects = new Map();
+const users = new Map();
+const jobs = [];
+const exportHistory = [];
+
+app.use(cors());
+app.use(express.json({ limit: '2mb' }));
+
+function ensureAuth(req, res, next) {
+  const token = req.headers.authorization?.replace('Bearer ', '');
+  if (!token) {
+    return res.status(401).json({ error: 'Missing token' });
+  }
+
+  try {
+    const decoded = jwt.verify(token, process.env.JWT_SECRET ?? 'dev-secret');
+    req.user = decoded;
+    return next();
+  } catch {
+    return res.status(401).json({ error: 'Invalid token' });
+  }
+}
+
+function getOrCreateUser(userId) {
+  if (!users.has(userId)) {
+    users.set(userId, {
+      id: userId,
+      email: `${userId}@turnerai.local`,
+      tier: 'builder',
+      generationsUsed: 0,
+      projects: [],
+      createdAt: new Date().toISOString()
+    });
+  }
+  return users.get(userId);
+}
+
+function canGenerate(user, type, params) {
+  if (type === 'multiplayerTemplate' && !TIER_LIMITS[user.tier].multiplayer) {
+    return { allowed: false, reason: 'Multiplayer generation is Studio and Creator Elite only.' };
+  }
+
+  const limit = TIER_LIMITS[user.tier].monthlyGenerations;
+  if (Number.isFinite(limit) && user.generationsUsed >= limit) {
+    return { allowed: false, reason: 'Generation quota exceeded for your tier.' };
+  }
+
+  if (params?.length > 1200) {
+    return { allowed: false, reason: 'Prompt too long.' };
+  }
+
+  return { allowed: true };
+}
+
+function encryptProject(payload) {
+  const keySource = process.env.ENCRYPTION_KEY ?? 'unsafe-dev-key-please-change';
+  const key = crypto.createHash('sha256').update(keySource).digest();
+  const iv = crypto.randomBytes(16);
+  const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
+  let encrypted = cipher.update(JSON.stringify(payload), 'utf8', 'base64');
+  encrypted += cipher.final('base64');
+  return { iv: iv.toString('base64'), blob: encrypted };
+}
+
+function fakeGenerationPayload(type, prompt) {
+  if (type === 'scene3d') {
+    return {
+      glbUrl: '/assets/generated/scene.glb',
+      textureAtlasUrl: '/assets/generated/atlas.png',
+      lightingPreset: 'torch-fog-night',
+      collisionMeshes: ['terrain_col', 'castle_wall_col'],
+      optimization: { targetPolyCount: 48000, lods: 3 },
+      prompt
+    };
+  }
+
+  if (type === 'gameLogic') {
+    return {
+      movement: 'generated-player-controller',
+      enemyAI: 'generated-zombie-wave-ai',
+      healthSystem: 'generated-health-system',
+      winLoss: 'generated-objective-logic',
+      exports: {
+        robloxLua: '-- Roblox Lua template',
+        unityCSharp: '// Unity C# template',
+        unrealCpp: '// Unreal C++ starter template'
+      },
+      prompt
+    };
+  }
+
+  if (type === 'npc') {
+    return {
+      dialogueTree: ['Greeting', 'Quest Offer', 'Quest Completion'],
+      rewards: ['Gold', 'Potion'],
+      interactionTrigger: 'Press E near NPC',
+      prompt
+    };
+  }
+
+  return {
+    serverAuthorityTemplate: 'generated-server-authority.js',
+    playerSyncTemplate: 'generated-player-sync.js',
+    lobbyTemplate: 'generated-lobby-template.js',
+    prompt
+  };
+}
+
+app.post('/api/auth/dev-login', (req, res) => {
+  const schema = z.object({ userId: z.string().min(2), email: z.string().email().optional() });
+  const parsed = schema.safeParse(req.body);
+  if (!parsed.success) {
+    return res.status(400).json({ error: parsed.error.flatten() });
+  }
+
+  const { userId, email } = parsed.data;
+  const user = getOrCreateUser(userId);
+  if (email) {
+    user.email = email;
+  }
+
+  const token = jwt.sign({ sub: user.id, tier: user.tier, email: user.email }, process.env.JWT_SECRET ?? 'dev-secret', {
+    expiresIn: '12h'
+  });
+
+  return res.json({ token, user });
+});
+
+app.get('/api/dashboard', ensureAuth, (req, res) => {
+  const user = getOrCreateUser(req.user.sub);
+  const tierMeta = TIER_LIMITS[user.tier];
+
+  return res.json({
+    user: {
+      id: user.id,
+      email: user.email,
+      tier: user.tier,
+      generationsUsed: user.generationsUsed,
+      generationsRemaining: Number.isFinite(tierMeta.monthlyGenerations)
+        ? Math.max(tierMeta.monthlyGenerations - user.generationsUsed, 0)
+        : 'unlimited'
+    },
+    projects: user.projects.map((id) => projects.get(id)),
+    exportHistory: exportHistory.filter((item) => item.userId === user.id).slice(-20)
+  });
+});
+
+app.post('/api/projects', ensureAuth, (req, res) => {
+  const schema = z.object({ name: z.string().min(3), scene: z.record(z.any()) });
+  const parsed = schema.safeParse(req.body);
+  if (!parsed.success) {
+    return res.status(400).json({ error: parsed.error.flatten() });
+  }
+
+  const user = getOrCreateUser(req.user.sub);
+  const projectId = uuidv4();
+  const encrypted = encryptProject(parsed.data.scene);
+
+  const project = {
+    id: projectId,
+    ownerId: user.id,
+    name: parsed.data.name,
+    encryptedScene: encrypted,
+    createdAt: new Date().toISOString(),
+    updatedAt: new Date().toISOString()
+  };
+
+  projects.set(projectId, project);
+  user.projects.push(projectId);
+
+  return res.status(201).json({ projectId });
+});
+
+app.post('/api/generate', ensureAuth, (req, res) => {
+  const schema = z.object({
+    type: z.enum(['scene3d', 'gameLogic', 'npc', 'multiplayerTemplate']),
+    prompt: z.string().min(4).max(1200),
+    projectId: z.string().optional()
+  });
+  const parsed = schema.safeParse(req.body);
+
+  if (!parsed.success) {
+    return res.status(400).json({ error: parsed.error.flatten() });
+  }
+
+  const user = getOrCreateUser(req.user.sub);
+  const auth = canGenerate(user, parsed.data.type, parsed.data.prompt);
+  if (!auth.allowed) {
+    return res.status(403).json({ error: auth.reason });
+  }
+
+  const jobId = uuidv4();
+  const job = {
+    id: jobId,
+    userId: user.id,
+    status: 'queued',
+    input: parsed.data,
+    createdAt: new Date().toISOString()
+  };
+  jobs.push(job);
+  user.generationsUsed += 1;
+
+  setTimeout(() => {
+    job.status = 'complete';
+    job.output = fakeGenerationPayload(parsed.data.type, parsed.data.prompt);
+    job.completedAt = new Date().toISOString();
+  }, 300);
+
+  return res.status(202).json({ jobId, status: job.status });
+});
+
+app.get('/api/generate/:jobId', ensureAuth, (req, res) => {
+  const job = jobs.find((item) => item.id === req.params.jobId && item.userId === req.user.sub);
+  if (!job) {
+    return res.status(404).json({ error: 'Job not found' });
+  }
+  return res.json(job);
+});
+
+app.post('/api/export', ensureAuth, (req, res) => {
+  const schema = z.object({
+    projectId: z.string().min(1),
+    format: z.enum(['zip', 'rbxm', 'unitypackage', 'unreal', 'obj', 'glb'])
+  });
+  const parsed = schema.safeParse(req.body);
+  if (!parsed.success) {
+    return res.status(400).json({ error: parsed.error.flatten() });
+  }
+
+  const user = getOrCreateUser(req.user.sub);
+  const limits = TIER_LIMITS[user.tier];
+  const premiumFormat = ['rbxm', 'unitypackage', 'unreal'].includes(parsed.data.format);
+
+  if (premiumFormat && !limits.canExportEngines) {
+    return res.status(403).json({ error: 'Upgrade to Pro or higher for this export format.' });
+  }
+
+  exportHistory.push({
+    id: uuidv4(),
+    userId: user.id,
+    projectId: parsed.data.projectId,
+    format: parsed.data.format,
+    watermarked: limits.watermark,
+    createdAt: new Date().toISOString()
+  });
+
+  return res.json({
+    downloadUrl: `/downloads/${parsed.data.projectId}.${parsed.data.format === 'zip' ? 'zip' : parsed.data.format}`,
+    watermarked: limits.watermark
+  });
+});
+
+app.post('/api/subscription/set-tier', ensureAuth, (req, res) => {
+  const schema = z.object({ tier: z.enum(['builder', 'pro', 'studio', 'creatorElite']) });
+  const parsed = schema.safeParse(req.body);
+  if (!parsed.success) {
+    return res.status(400).json({ error: parsed.error.flatten() });
+  }
+
+  const user = getOrCreateUser(req.user.sub);
+  user.tier = parsed.data.tier;
+  return res.json({ ok: true, tier: user.tier });
+});
+
+app.post('/api/stripe/webhook', express.raw({ type: 'application/json' }), (req, res) => {
+  if (!stripe || !process.env.STRIPE_WEBHOOK_SECRET) {
+    return res.status(501).json({ error: 'Stripe not configured' });
+  }
+
+  const signature = req.headers['stripe-signature'];
+  try {
+    stripe.webhooks.constructEvent(req.body, signature, process.env.STRIPE_WEBHOOK_SECRET);
+    return res.json({ received: true });
+  } catch {
+    return res.status(400).json({ error: 'Invalid Stripe signature' });
+  }
+});
+
+app.get('/health', (_req, res) => {
+  res.json({ status: 'ok', service: 'turnerai-api' });
+});
+
+app.listen(port, () => {
+  console.log(`TurnerAI API running on port ${port}`);
+});
 
EOF
)
